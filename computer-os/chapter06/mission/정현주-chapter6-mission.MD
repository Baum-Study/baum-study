# 동적 메모리 할당
런타임에 메모리 할당이 가능하기 때문에 프로그램의 실행 중에 동적으로 메모리를 할당하고 해제할 수 있습니다.  
이는 필요한 만큼의 메모리만 할당하여 메모리의 효율성을 높일 수 있습니다.
</br>
</br>
단, 메모리를 명시적으로 해제하지 않으면 메모리 누수가 발생할 수 있으며, 동적 할당 및 해제 과정에 대한 오버헤드가 발생할 수 있습니다.
</br>
</br>
```kotiln
fun main() {
    // 런타임에 배열의 크기를 결정하고 메모리를 할당
    val size = readLine()?.toIntOrNull() ?: 0
    val dynamicArray = IntArray(size)
    
    // 필요에 따라 동적으로 메모리를 할당하고 해제
    if (size > 100) {
        // 큰 배열을 처리하는 경우 추가 메모리를 동적으로 할당
        val extraMemory = IntArray(size * 2)
        // extraMemory 사용 후 해제
    }
    // dynamicArray 사용 후 해제
}
```
</br>
</br>

# 정적 메모리 할당
컴파일 타임에 메모리가 할당되기 때문에 실행 시간에 추가적인 할당 및 해제 과정이 필요하지 않아 실행 속도가 빠를 수 있습니다.  
이렇게 메모리 할당과 해제가 컴파일 타임에 이루어지기 때문에 실행 중에 예기치 않은 메모리 관련 문제가 발생할 가능성이 줄어듭니다.
</br>
</br>
단, 실행 중에 동적으로 메모리를 조작하는 것이 불가능하여 프로그램의 유연성이 제한될 수 있으며, 컴파일 시점에 할당된 메모리의 크기가 정적으로 결정되기 때문에 실제 필요한 메모리보다 많은 메모리를 할당할 수 있습니다.
</br>
</br>
```kotiln
// 컴파일 타임에 배열의 크기를 결정
const val ARRAY_SIZE = 100

fun main() {
    // 컴파일 타임에 결정된 배열 크기에 따라 메모리를 할당함
    val staticArray = IntArray(ARRAY_SIZE)
    
    // 정적으로 할당된 배열을 사용함
    for (i in 0 until ARRAY_SIZE) {
        // staticArray 사용
    }
    // staticArray 사용 후 해제 (정적 할당이므로 명시적인 해제가 필요하지 않음)
}

```
