# 프로세스 동기화
프로세스 동기화는 크게 실행 순서 제어와 상호 배제 두 가지를 의미합니다.
</br>
</br>
## 1. 실행 순서 제어를 위한 동기화 (Reader Writer Problem)
프로세스를 올바른 순서대로 실행하는 것입니다.
#### * Writer : 값을 저장하는 프로세스
#### * Reader : 저장된 값을 읽어들이는 프로세스
</br>
Reader 프로세스는 "값이 존재한다"라는 특정 조건이 만족되어야만 실행이 가능하므로, Writer 프로세스의 실행이 끝난 뒤에 실행할 수 있습니다.  
즉, Reader와 Writer 프로세스는 실행의 순서가 있기 때문에 아무렇게나 실행되어서는 안됩니다.
</br>
</br>
</br>

## 2. 상호 배제 (Banck Account Problem)
동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하는 것입니다.  
즉, 공유가 불가능한 자원의 동시 사용을 피하기 위한 동기화입니다.
</br>
</br>
동시에 접근해서는 안 되는 자원에는 공유 자원 중 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역인 임계 구역의 코드들이 있습니다.  
따라서, 임계 구역에 진입하고자 하면 진입한 프로세스 이외에는 대기해야 합니다.
</br>
</br>
만약 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있으며, 이를 race condition이라 합니다.
</br>
</br>
운영체제는 이러한 임계 구역 문제를 해결하기 위해 다음과 같은 원칙을 지킵니다.
* #### 상호 배제 (mutual exclusion)
  한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없습니다.
* #### 진행 (progress)
  임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 합니다.
* #### 유한 대기 (bounded waiting)
  한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 합니다.  
  즉, 임계 구역에 들어오기 위해 무한정 대기해서는 안 됩니다.
</br>
</br>
</br>
</br>
</br>

# 동기화 기법
## 1. 뮤텍스 락
상호 배제를 위한 동기화 도구입니다. 자물쇠 역할을 한다고 볼 수 있습니다.
</br>
</br>
이해를 위해 간단하게 코드로 구현해 보자면 다음과 같습니다.
```kotlin
class Mutex {
  private var lock = false

  fun acquire() {
    while (lock) {} // 임계 구역 확인
    lock = true // 임계 구역 잠금
  }

  fun release() {
    lock = false // 임계 구역 잠금 해제
  }
}

fun main() {
  val mutex = Mutex()

  // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
  mutex.acquire()

  // 임계 구역에서의 작업 진행

  // 자물쇠 반환
  mutex.release()
}
```
acquire 함수는 프로세스가 임계 구역에 진입하기 전에 호출합니다.  
만약 임계 구역이 잠겨 있다면, 임계 구역이 열릴 때까지(false) 임계 구역을 반복적으로 확인합니다. (busy waiting)  
반대로 임계 구역이 열려 있다면, 임계 구역을 잠급니다.(true)
</br>
</br>
release 함수는 임계 구역에서의 작업이 끝나고 호출합니다.  
현재 잠긴 임계 구역을 여는(false) 역할입니다.
</br>
</br>
</br>
## 2. 세마포
뮤텍스 락보다는 일반화된 방식의 동기화 도구입니다.  
공유 자원이 하나만 있는 경우를 상정한 뮤텍스 락과 달리 공유 자원이 여러 개 있는 경우에도 적용 가능한 방법입니다.
</br>
</br>
세마포는 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리고, 가도 좋다는 신호를 받으면 임계 구역에 진입하는 방식입니다.
</br>
</br>
이해를 위해 간단하게 코드로 구현해 보자면 다음과 같습니다.
```kotlin
class Semaphore(initial: Int) {
  private var S = initial

  fun wait() {
    while (S <= 0) {} // 임계 구역 확인
    S-- // 임계 구역 진입
  }

  fun signal() {
    S++ // 임계 구역 작업 완료 후 자원 반환
  }
}

fun main() {
  val semaphore = Semaphore(2) // 공유 자원의 개수

  // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
  semaphore.wait()

  // 임계 구역에서의 작업 진행

  // 자물쇠 반환
  semaphore.signal()
}
```
S는 임계 구역에 진입할 수 있는 프로세스 개수(공유 자원의 개수)입니다.
</br>
</br>
wait 함수에서 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 사용할 수 있는 자원이 있는지 반복적으로 확인하고(busy waiting), 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이라면 S를 1 감소시키고 임계 구역에 진입합니다.
</br>
</br>
signal 함수는 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킵니다.  
즉, 임계 구역에 진입할 수 있는 프로세스의 개수를 1 증가시키는 것입니다.
</br>
</br>
또한 세마포는 실행 순서를 위한 동기화도 제공합니다.  
세마포의 변수 S를 0으로 두고, 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 됩니다.
</br>
</br>
</br>
뮤텍스 락과 세마포에서 나온 busy waiting 방법은 계속해서 while 문을 돌기 때문에 쓸데없이 CPU 사이클이 낭비될 수 있으므로 좋은 방법이 아닙니다.
</br>
</br>
이를 해결하기 위해 프로세스의 상태를 바꿈으로써 CPU의 불필요한 사이클 낭비를 방지합니다.  
사용할 수 있는 자원이 없을 경우, 대기 상태로 만듭니다. (해당 프로세스의 PCB를 대기 큐에 삽입)  
사용할 수 있는 자원이 생겼을 경우, 대기 큐의 프로세스를 준비 상태로 만듭니다. (해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)
</br>
</br>
</br>
## 3. 모니터
매번 임계 구역 앞뒤로 wait(), signal()를 호출하는 방식은 작은 실수로 인해 큰 문제가 발생할 수 있습니다.  
순서를 헷갈리거나 중복해서 사용하거나 세마포를 누락한 경우에 발생하는 문제는 특히나 디버깅하기도 어렵습니다.  
이러한 단점을 해결하기 위해 나온 것이 모니터입니다.
</br>
</br>
모니터는 사용자가 다루기에 편한 동기화 도구라고 볼 수 있습니다.  
이 모니터는 상호 배제를 위한 동기화와 실행 순서 제어를 위한 동기화 모두 제공해 줍니다.
</br>
</br>
* #### 상호 배제를 위한 동기화
  ![img](../image/정현주-image1.png)
  모니터는 공유 자원과 공유 자원에 접근하기 위한 통로를 묶어 관리합니다.  
  또한 공유 자원에 접근하고자 하는 프로세스와 스레드는 반드시 특정 인터페이스를 통해서만 접근하도록 합니다.
  </br>
  </br>
  이 인터페이스를 위한 큐가 있고, 큐에 삽입되어 있기 때문에 한 번에 하나의 프로세스만 된 순서대로 공유 자원을 이용할 수 있습니다.

* #### 실행 순서 제어를 위한 동기화
  ![img](../image/정현주-image2.png)
  내부적으로 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 조건 변수를 사용합니다.  
  이는 wait(), signal()를 호출할 수 있는 변수입니다.
  </br>
  </br>
  모니터 내부에는 각각의 조건 변수마다 큐가 만들어져 있고, 이를 통해 실행 순서를 제어합니다.  
  이때 상호 배제를 위한 큐와 조건 변수를 위한 큐는 다릅니다.
  </br>
  </br>
  모니터 안에는 하나의 프로세스만이 있을 수 있고, 이에 두 가지 방식이 있을 수 있습니다.  
  첫째, wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재개하는 방식입니다.  
  둘째, signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal()을 호출한 프로세스의 수행을 재개하는 방식입니다.
