# ALU와 제어장치

## ALU(Arithmehtic Logic Unit)

### **ALU란?**

ALU는 산술 논리 연산 장치로, 산술 연산 및 논리 연산을 수행하는 컴퓨터의 구성 요소 입니다.

피연산자를 레지스터에서 받아들이고, 제어장치로부터 어떤 연산을 수행할지 알려주는 제어 신호를 받습니다.

### ALU가 내보내는 정보

ALU는 연산 결과를 레지스터에 임시 저장합니다. 메모리보다 레지스터에 접근하는 속도가 훨씬 빠르기 때문에, 프로그램 실행 속도를 향상시키는데 기여합니다. 만약 ARU가 연산시 메모리에 모든 데이터를 저장하게 된다면 CPU가 메모리에 자주 접근하게 되기 때문에 프로그램 실행 속도가 느려집니다.

### **플래그**

플래그는 ALU에서 수행한 연산의 결과를 기반으로 추가적인 상태 정보를 제공하는 작은 표시기들입니다. 다양한 종류의 플래그들이 있으며, 각각은 연산 결과에 따라 특정한 상태를 나타냅니다.

- **부호 플래그**: 연산 결과가 음수일 때 1을 설정하고, 그렇지 않을 경우 0을 설정합니다. 이 플래그는 연산 결과의 부호를 나타냅니다.
- **제로 플래그**: 연산 결과가 0일 경우 1을, 0이 아닐 경우 0을 설정합니다. 이는 연산 결과가 제로인지 아닌지를 체크하는 데 사용됩니다.
- **캐리 플래그**: 연산에서 올림수가 발생했을 경우 1을, 발생하지 않았을 경우 0을 설정합니다. 또한 빼기 연산에서 빌림수가 발생했을 때도 사용됩니다.
- **오버플로우 플래그**: 연산 결과가 데이터 타입의 범위를 초과하여 오버플로우가 발생한 경우 1을 설정합니다. 정수 타입의 최대치나 최소치를 넘어선 경우에 이 플래그가 활성화됩니다.
- **인터럽트 플래그**: CPU가 인터럽트를 받아들일 수 있는 상태일 때 1을 설정하며, 그렇지 않을 때는 0을 설정합니다. 이 플래그는 시스템의 인터럽트 활성 상태를 제어합니다.
- **슈퍼바이저 플래그**: 시스템이 커널 모드에서 실행 중일 때 1을, 사용자 모드에서 실행 중일 때는 0을 설정합니다. 이 플래그는 운영체제의 보안 및 모드 관리에 중요한 역할을 합니다.

## 제어장치

제어장치는 CPU의 명령어를 해석하고 해당 명령어에 따라 제어 신호를 생성하여 CPU의 다른 부품들을 제저합니다.

1. 클럭 신호에 의해 주기적으로 데이터 가 이동, ALU 연산, 명령어 로드 등을 조절하며 시스템 동기화합니다.
    
    > 클럭(Clock)은 컴퓨터 내에서 동기화를 위해 사용되는 시그널로서, 컴퓨터의 모든 구성 요소들이 클럭 신호에 맞춰 데이터를 처리하고 명령을 수행하도록 조절합니다. 이 클럭 신호는 정확한 타이밍에 따라 주기적으로 발생하는 전기적 펄스 또는 신호로서, 컴퓨터 시스템의 '맥박'과 같은 역할을 합니다.
    > 
2. 명령어 레지스터에서 명령어를 받아들여 해석하고, 필요한 제어 신호를 생성하여 다른 컴퓨터 부품들에게 수행해야할 내용을 전달합니다.
3. 플래그 레지스터의 플래그 값을 확인하여 추가적인 제어 신호를 조절할 수 있습니다.
4. 제어버스를 통해 외부의 제어 신호를 받아들이고, CPU 내 외부로 제어 신호를 보냅니다.

# 레지스터

레지스터는 CPU 내부에서 명령어와 데이터를 임시로 저장하는 작은 메모리 입니다.

각 레지스터는 특정 목적을 가지고 있으며 프로그램 실행 흐름과 CPU내부 연산에 핵심적인 역할을 합니다.

1. **프로그램 카운터(Program Counter, PC)**
    - 다음에 실행할 명령어의 메모리 주소를 저장합니다. 명령어 포인터로도 불리며, 프로그램의 실행 순서를 결정하는 데 중요합니다. → 읽어들일 명령어의 주소를 포함하기때문
2. **명령어 레지스터(Instruction Register, IR)**
    - CPU가 현재 해석하고 있는 명령어를 저장합니다. 명령어 레지스터에서 읽은 명령어는 제어장치에 의해 분석되어 필요한 제어 신호를 생성합니다.
3. **메모리 주소 레지스터(Memory Address Register, MAR)**
    - CPU가 데이터를 읽거나 쓸 메모리의 주소를 저장합니다. 이 주소는 주소 버스를 통해 메모리로 전송됩니다.
4. **메모리 버퍼 레지스터(Memory Buffer Register, MBR)**
    - 메모리와 CPU 사이의 데이터 교환을 중개합니다. 메모리로부터 읽은 데이터나 메모리에 쓸 데이터를 일시적으로 저장합니다. 이 레지스터는 데이터 버스를 통해 데이터를 전송합니다.
5. **범용 레지스터(General Purpose Registers, GPR)**
    - 다양한 용도로 사용될 수 있는 레지스터로, 데이터와 주소를 유동적으로 저장할 수 있습니다. 프로그램의 특정 요구에 따라 다르게 사용됩니다.
    
    > **범용 레지스터의 활용 예**
    > 
    > 1. **데이터 연산**: 범용 레지스터는 각종 산술 및 논리 연산에 사용되는 데이터를 임시로 저장합니다. 예를 들어, 두 숫자의 합을 계산할 때, 각 숫자는 먼저 범용 레지스터에 로드되고, 연산 결과 또한 레지스터에 저장됩니다.
    > 2. **주소 계산**: 메모리에서 데이터를 읽거나 쓰기 위한 주소를 계산할 때 범용 레지스터가 사용됩니다. 예를 들어, 배열에 접근하는 경우, 배열의 시작 주소와 인덱스를 이용한 주소 계산이 범용 레지스터를 통해 이루어질 수 있습니다.
    > 3. **함수 매개변수 전달**: 프로그램에서 함수를 호출할 때, 매개변수는 종종 범용 레지스터를 통해 전달됩니다. 이는 스택을 사용하는 방법보다 빠를 수 있으며, 레지스터를 통해 데이터를 직접 전달함으로써 처리 속도를 향상시킵니다.
    > 4. **임시 데이터 저장**: 계산 중에 발생하는 임시 데이터들은 범용 레지스터에 저장되어 다음 계산 단계로 넘어갈 때까지 보관됩니다.
6. **플래그 레지스터(Flag Register)**
    - CPU의 연산 결과에 따른 상태 정보를 비트 형태로 저장합니다. 이 정보는 CPU의 다음 동작을 결정하는 데 사용됩니다.
7. **스택 포인터(Stack Pointer, SP)**
    - 현재 스택의 꼭대기를 가리키는 주소를 저장합니다. 스택 포인터는 함수 호출과 반환, 임시 데이터 저장 등에 사용되며 프로그램의 실행 상태를 관리하는 데 중요한 역할을 합니다.
    
    > **스택 포인터의 중요성**
    > 
    > 1. **함수 호출과 반환**: 프로그램에서 함수를 호출할 때, 현재 실행 중인 함수의 실행 상태(지역 변수, 반환 주소 등)가 스택에 저장됩니다. 스택 포인터는 이러한 정보가 저장된 스택의 위치를 가리키므로, 함수가 종료되고 제어가 호출한 함수로 반환될 때, 이전 상태로 정확히 복구할 수 있게 합니다. 이를 통해 함수의 중첩 호출과 재귀적 실행이 가능해집니다.
    > 2. **임시 데이터 저장**: 계산 중 생성되는 임시 변수나 중간 결과를 저장하는 데 스택이 사용됩니다. 스택 포인터는 이러한 데이터들이 저장되는 위치를 관리하므로, 필요할 때 쉽게 접근하고 사용할 수 있습니다.
    > 3. **프로그램의 실행 상태 관리**: 프로그램이 실행되는 동안, 스택 포인터는 현재 실행 중인 프로그램의 상태를 나타내는 중요한 정보의 인덱스 역할을 합니다. 예를 들어, 예외 처리나 인터럽트 발생 시 스택에 저장된 정보를 통해 프로그램의 실행을 일시 중단하고, 처리 후에 원래의 실행 상태로 복귀할 수 있습니다.
    > 4. **스레드 및 병렬 처리**: 멀티 스레딩 환경에서 각 스레드는 독립적인 스택을 가지며, 스택 포인터는 각 스레드의 스택을 개별적으로 관리합니다. 이를 통해 각 스레드가 독립적으로 실행 상태를 관리하면서도 시스템 자원을 효율적으로 활용할 수 있습니다.
8.  **베이스 레지스터(Base Register)**
    - 프로그램이 메모리의 다양한 위치에 접근할 필요가 있을 때, 베이스 레지스터는 그 시작 주소 또는 참조점 역할을 합니다.
    - **변위 주소 지정 방식**:
        - 이 방식에서는 오퍼랜드의 필드값과 베이스 레지스터의 값이 합쳐져 유효 주소를 형성합니다. 이 주소는 데이터나 명령어의 실제 메모리 위치를 가리키게 됩니다.
        1. **상대 주소 지정방식**:
            - 프로그램 카운터와 오퍼랜드를 합하여 유효 주소를 얻는 방식입니다. 이 방식은 주로 점프 명령어나 분기 명령어에서 사용되며, 실행 중인 코드의 상대적 위치를 기준으로 다른 코드 세그먼트로 이동할 때 활용됩니다.
            - 만약 오퍼랜드가 음수 -3이라면 읽어 들이기로 한 명령어로 부터 세 번째 이전 번지로 접근
        2. **베이스 레지스터 주소 지정 방식**:
            - 베이스 레지스터와 오퍼랜드를 더해 최종적인 메모리 주소를 결정합니다.
            - 베이스 레지스터 200, 오퍼랜드 40 이라면 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근

# 명령어 사이클과 인터럽트

## **명령어 사이클**

CPU가 하나의 명령어를 처리하는 과정은 여러 단계로 나뉘며, 이 과정들이 반복적으로 실행되어 프로그램을 처리합니다. 명령어 사이클은 다음과 같은 순서로 진행됩니다.

1. **인출 사이클(Fetch Cycle)**
    - 프로그램 카운터(PC)에 저장된 주소에서 명령어를 메모리로부터 인출합니다.
    - 인출된 명령어 주소는 메모리 주소 레지스터(MAR)로 전달되며, 메모리에서 읽기 제어 신호와 함께 제어 버스 및 주소 버스를 통해 전송됩니다.
    - 데이터 버스를 통해 인출된 명령어는 메모리 버퍼 레지스터(MBR)로 이동한 후 명령어 레지스터(IR)로 전달됩니다.
    - 프로그램 카운터는 다음 명령어를 인출할 준비를 위해 증가합니다.
2. **실행 사이클(Execute Cycle)**
    - 명령어 레지스터(IR)에 저장된 명령어를 해석하고 실행합니다. 이 과정에서 CPU 내의 ALU가 필요한 연산을 수행할 수 있습니다.
3. **간접 사이클(Indirect Cycle)**
    - 간접 주소 방식을 사용하는 명령어의 경우, 오퍼랜드 필드에 저장된 유효 주소의 주소를 통해 최종 데이터 위치를 확인하기 위해 추가 메모리 접근이 필요합니다. 이 단계에서는 실제 데이터 주소를 얻기 위한 추가적인 메모리 접근이 발생합니다.

## **인터럽트**

CPU가 수행 중인 작업을 잠시 중단하고 긴급하게 처리해야 할 다른 작업(인터럽트)에 응답하는 기능입니다. 이는 프로그램의 흐름을 변경하여 특정 이벤트에 신속하게 대응할 수 있게 합니다.

### **동기 인터럽트**

동기 인터럽트는 CPU 자체의 연산 과정에서 발생하는 예외 상황에 의해 발생합니다. 이러한 인터럽트는 프로그램 실행 중 예측 가능한 시점에 발생하며, 주로 다음과 같은 형태로 나타납니다:

1. **폴트(Fault)**: 오류가 발생하면, CPU는 예외를 처리한 직후 예외가 발생한 명령어부터 실행합니다.
2. **트랩(Trap)**: 주로 디버깅 용도로 사용되며, 처리 후 다음 명령어로 넘어갑니다.
3. **중단(Abort)**: 회복이 불가능한 심각한 오류 발생 시 프로그램 실행을 중단합니다.
    1. 하드웨어결함, 리소스 손상 등
4. **소프트웨어 인터럽트**: 프로그램이 명시적으로 인터럽트를 발생시켜 CPU의 주의를 요구할 때 사용됩니다.

### **비동기 인터럽트(하드웨어 인터럽트)**

외부 이벤트(주로 입출력 장치)로부터 발생하는 인터럽트로, 예기치 않은 시점에 발생할 수 있습니다. 처리 과정은 다음과 같습니다:

1. **인터럽트 요청 신호**: 입출력 장치가 인터럽트를 CPU에게 전송합니다.
2. **인터럽트 검사**: CPU는 명령어 사이클의 마지막에서 인터럽트의 유무를 확인합니다.
3. **인터럽트 플래그 확인**: 인터럽트 플래그를 확인하여 현재 CPU가 인터럽트를 받아들일 준비가 되어 있는지를 판단합니다.
4. **작업의 백업**: 인터럽트를 처리하기 전 현재까지의 작업을 스택에 백업합니다.
5. **인터럽트 서비스 루틴 실행**: 인터럽트 벡터를 사용하여 적절한 인터럽트 서비스 루틴을 찾고 실행합니다.
6. **작업 재개**: 인터럽트 처리가 완료되면 백업된 작업을 복구하고 프로그램을 계속 실행합니다.

인터럽트 벡터는 각 인터럽트 유형별로 서비스 루틴의 시작 주소를 가리키는 정보입니다. 이는 CPU가 정확한 처리 루틴을 신속하게 찾아 실행할 수 있도록 도와줍니다.
