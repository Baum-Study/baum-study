# 도커를 알아야 하는 이유

도커로 배포된 이미지를 사용하면 도커를 몰라도 쿠버네티스 환경을 구축하고 사용할 수 있습니다. 하지만 쿠버네티스는 컨테이너 기술을 기반으로 하기 때문에, 트러블슈팅을 제대로 수행하려면 컨테이너에 대한 깊은 이해가 필요합니다.

## 파드, 컨테이너, 도커, 쿠버네티스의 관계

쿠버네티스 클러스터 내의 각 컨테이너는 독립적으로 작동합니다. 여러 컨테이너를 효과적으로 관리하기 위해 등장한 도구가 바로 도커입니다. 도커는 컨테이너를 다루는 방법을 명령어로 정리한 것입니다. 도커를 사용하면 사용자가 별도로 신경 쓰지 않아도, 컨테이너 생성 시 개별적인 실행 환경이 분리되고 자원이 자동으로 할당됩니다.

# 도커로 컨테이너 다루기

### 컨테이너 이미지와 컨테이너의 관계

컨테이너 이미지는 도커와 같은 CRI(컨테이너 런타임 인터페이스)를 통해 불러와야 실제로 작동합니다. 이는 실행 파일과 실행된 파일의 관계로 볼 수 있습니다. 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야 디스크 용량을 온전히 확보할 수 있습니다.

### 컨테이너 이미지 알아보기

**이미지 검색 및 내려받기**

이미지는 "레지스트리"라고 불리는 저장소에 저장됩니다. 별도의 레지스트리를 지정하지 않으면 기본적으로 도커 허브에서 이미지를 찾습니다.

```bash
$ docker search <검색어>
NAME                     DESCRIPTION                     STARS  OFFICIAL  AUTOMATED
centos                   The official build of CentOS.   3620   [OK]
ansible/centos7-ansible  Ansible on Centos7              100
```

- **INDEX**: 이미지가 저장된 레지스트리의 이름
- **NAME**: 검색된 이미지의 이름, 공식 이미지를 제외한 나머지는 ‘레지스트리 주소/저장소 소유자/이미지 이름’의 형태로 표시됩니다.
- **DESCRIPTION**: 이미지에 대한 설명
- **STARS**: 이미지의 평가 횟수
- **OFFICIAL**: [OK] 표시는 해당 이미지를 개발한 업체에서 공식적으로 제공한 이미지임을 나타냅니다.
- **AUTOMATED**: [OK] 표시는 도커 허브에서 제공하는 이미지 빌드 자동화 기능을 활용해 생성된 이미지를 의미합니다.

```bash
$ docker pull <이미지이름>
Using default tag: latest
latest: Pulling from library/nginx
2408cc74d12b: Pull complete
0a79b6f7bb4b: Pull complete
a25a0d15ecf5: Pull complete
Digest: sha256:5bb2a35ec1fe8b3de6e6b2e65c0dd6e51f110bddef34bc0f90efc8b802a4cabc
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest
```

- **태그(tag)**: 이미지를 내려받을 때 사용된 태그입니다. 별도의 조건을 주지 않으면 `latest` 태그가 적용됩니다.
- **레이어(layer)**: 하나의 이미지는 여러 개의 레이어로 구성되며, 각 레이어가 다운로드될 때 `pull complete` 메시지가 나타납니다.
- **다이제스트(digest)**: 이미지의 고유 식별자로, 이미지의 내용과 생성 환경을 식별할 수 있습니다. 이 식별자는 해시 함수로 생성되며, 이미지가 동일한지 검증하는 데 사용됩니다. 이름이나 태그는 이미지를 생성할 때 임의로 지정되므로, 이름이나 태그가 같다고 해서 동일한 이미지라고 할 수 없습니다.
- **상태(status)**: 이미지를 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있습니다.

**이미지 태그**

태그는 동일한 이미지에 추가하는 식별자입니다. 동일한 이름의 이미지라도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하기 위해 태그가 사용됩니다. 이미지를 내려받거나 이미지를 기반으로 컨테이너를 구동할 때 이미지 이름만 사용하고 태그를 명시하지 않으면, `latest` 태그가 기본으로 사용됩니다.

**이미지 레이어 구조**

이미지는 애플리케이션과 다양한 파일을 포함하고 있다는 점에서 ZIP 같은 압축 파일에 가깝습니다. 동일한 내용이 여러 이미지에 포함될 경우, 동일한 레이어를 공유함으로써 전체 용량이 줄어듭니다.

### 컨테이너 실행하기

```bash
$ docker run -d -p <호스트 포트>:<컨테이너 포트> --restart always <이미지 이름>
```

- 컨테이너 생성 시 컨테이너를 식별할 수 있는 고유 ID가 생성됩니다.
- **d(—detach)**: 컨테이너를 백그라운드에서 구동합니다.
- **—restart always**: 프로그램에 예상치 못한 오류가 발생하거나, 리눅스 시스템에서 도커 서비스가 중지되는 경우, 컨테이너도 작동이 중지됩니다. 이때 중지된 컨테이너를 즉시 재시작하거나, 리눅스 시스템에서 도커 서비스가 시작될 때 자동으로 컨테이너를 시작하도록 설정할 수 있습니다.
    - **on**: 컨테이너를 재시작하지 않음
    - **on-failure**: 오류 발생 시 컨테이너를 재시작
    - **always**: 항상 컨테이너를 재시작
    - **unless-stopped**: 비정상 종료 시 재시작, 도커 서비스 시작 시 사용자가 직접 정지하지 않은 컨테이너만 재시작
- **p(—publish)**: 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션

**컨테이너 상태 확인**

```bash
$ docker ps
CONTAINER ID   IMAGE         COMMAND                  CREATED        STATUS        PORTS                  NAMES
e1c3f8e45b1d   nginx         "nginx -g 'daemon of…"   2 minutes ago  Up 2 minutes  0.0.0.0:80->80/tcp     nginx_web
4a432e75b1a6   mysql:5.7     "docker-entrypoint.s…"   5 minutes ago  Up 5 minutes  3306/tcp, 33060/tcp    mysql_db
b99a1fc65bca   redis         "docker-entrypoint.s…"   10 minutes ago Up 10 minutes 6379/tcp               redis_cache

$ docker ps -f(--filter) <필터링 대상> //검색 결과 필터링 가능
id, name, label, exited, status, ancestor
```

- **CONTAINER ID**: 컨테이너를 식별하기 위한 고유 ID
- **IMAGE**: 컨테이너를 만드는 데 사용된 이미지
- **COMMAND**: 컨테이너가 생성될 때 내부에서 실행할 프로그램을 실행하는 명령어
- **CREATED**: 컨테이너가 생성된 시각
- **STATUS**: 컨테이너가 작동을 시작한 시각
- **PORTS**: 컨테이너가 사용하는 포트와 프로토콜
- **NAMES**: 컨테이너의 이름 (`docker run —name <이름>`으로 직접 지정 가능)

### 컨테이너 내부 파일 변경하기

- **docker cp**: 컨테이너에 임시로 필요한 파일을 전송하거나, 컨테이너에 저장된 설정 및 로그를 추출해 확인할 때 사용됩니다.

```bash
$ docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로>
```

이 명령어를 사용해 호스트에 있는 파일을 구동 중인 컨테이너 내부에 복사할 수 있습니다.

- **Dockerfile ADD**: Dockerfile에서 `ADD` 구문을 사용해 컨테이너 내부로 복사할 파일을 지정하면, 이미지를 빌드할 때 해당 파일이 이미지 내부로 복사됩니다. 이후 이 이미지를 기반으로 구동한 컨테이너는 복사된 파일을 사용할 수 있습니다. 하지만 사용자가 원하는 파일을 선택해 사용할 수 없다는 단점이 있습니다.
- **바인드 마운트**: 호스트의 파일 시스템과 컨테이너 내부를 연결해, 어느 한쪽에서 작업한 내용이 양쪽에서 동시에 반영되는 방법입니다. 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있습니다. 컨테이너가 바뀌어도 없어지면 안 되는 자료는 이 방법으로 보존할 수 있습니다.
- **볼륨**: 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결합니다. 여기서 말하는 볼륨은 쿠버네티스의 볼륨 구조와 유사합니다. 도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉터리에 생성하면, 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있습니다.

```bash
$ docker volume create <볼륨 이름> // 볼륨 생성
$ docker volume inspect <볼륨 이름> // 볼륨 조회
```

### 사용하지 않는 컨테이너 정리하기

```bash
$ docker stop <컨테이너 이름|아이디> // 컨테이너 정지
$ docker stop $(docker ps -q -f <필터 검색 옵션>) // 필터링된 모든 컨테이너 정지
$ docker rm <컨테이너 이름|아이디> // 컨테이너 삭제
$ docker rm $(docker ps -aq -f <필터 검색 옵션>) // 필터링된 모든 정지된 컨테이너 삭제
$ docker rmi <이미지 이름> // 이미지 삭제
$ docker rmi $(docker images -q <이미지 이름>) // 이미지를 한 번에 삭제
```
