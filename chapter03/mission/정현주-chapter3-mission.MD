## 함수를 사용하는 이유
#### 1. 모듈성
  복잡한 프로그램을 작은 단위로 나눌 수 있습니다.  
  이는 각 부분을 독립적으로 개발하고 테스트할 수 있어 전체적인 개발 과정이 효율적이고 관리하기 쉬워집니다.

#### 2. 재사용성
  다양한 위치에서 여러 번 호출될 수 있습니다.  
  이를 통해 코드의 중복을 줄이고, 필요할 때마다 해당 함수를 재사용하여 효율적으로 프로그래밍할 수 있습니다.

#### 3. 추상화
  복잡한 작업을 숨기고, 간단한 인터페이스를 제공합니다.  
  이러한 추상화는 프로그램의 다른 부분이 어떻게 구현되었는지 걱정하지 않고도 그 기능을 사용할 수 있게 합니다.

#### 4. 가독성
  프로그램을 더 읽기 쉽고 이해하기 쉽게 만듭니다.  
  함수의 이름만 보고도 해당 함수가 수행하는 작업을 대략적으로 파악할 수 있습니다.
  
</br>

```kotlin
fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
    val result1 = add(2, 3)
    val result2 = add(result1, 5)

    println(result2)
}
```
</br>
</br>

## 오버헤드를 줄이는 방법
코틀린에서는 오버헤드를 줄이기 위해 inline 함수를 사용할 수 있습니다.

inline 함수는 컴파일 시 함수 호출이 함수 본문으로 대체되어 런타임에 함수 호출과 관련된 오버헤드를 없앨 수 있습니다.
즉, 아래의 add 함수가 호출될 때마다 컴파일러가 함수 호출 코드를 함수 본문의 코드로 직접 대체한다는 것을 의미합니다.
```kotlin
inline fun add(a: Int, b: Int): Int {
    return a + b
}

fun main() {
    val result1 = add(2, 3)
    val result2 = add(result1, 5)

    println(result2)
}
```
이로 인해 런타임에는 함수 호출의 추가 비용 없이 단순한 덧셈 연산만 수행되므로 실행 속도가 빨라집니다.
이 방법은 작은 함수의 경우 유리하지만, 함수가 크거나 복잡할 때는 코드의 크기가 커질 수 있으므로 사용에 주의해야 합니다.

즉, 인라인 함수는 호출 오버헤드를 없애지만, 결과적으로 생성되는 코드의 양이 많아져 프로그램의 전체 크기가 증가할 수 있습니다.
따라서 성능이 중요한 작은 함수에서 이점을 가질 수 있습니다.

