## 오버헤드

오버헤드는 직접적으로 작업의 결과물을 생성하지 않는, 하지만 작업을 수행하기 위해 필수적인 부분을 가리킵니다. 예를 들어서 함수를 호출할 때 발생하는 오버헤드에는 함수의 매개변수를 스택에 푸시하는 시작, 함수 호출 후 스택에서 매개변수를 팝하는 시간,함수 주소로 점프하는 시간 등이 포함됩니다. 이러한 오버헤드는 필요한 작업을 수행하는 과정에서 발생하는 부가적인 비용으로 간주될 수 있습니다.

### 오버헤드 예시

1. **매개변수 전달** : 매개변수 들은 함수로 전달 되어야 하기 때문에 스택에 푸시하고 팝하는 시간
2. **스택 프레임 생성**: 함수 호출 시, 함수의 지역 변수와 반환 주소를 저장하기 위한 새로운 스택 프레임이 생성 → 함수가 실행되는 동안 필요한 모든 정보를 포함
3. **함수로 이동**: 함수가 호출되면, 프로그램은 현재 실행중인 위치에서 함수의 시작 지점으로 이동해야 합니다. 이 떄 실행중인 코드의 위치(반환 주소)를 저장해야 하며, 함수 실행이 완료된 후 이 위치로 돌아와야 합니다.
4. **리턴**: 함수의 작업이 끝나면, 결과값을 반환하고 원래 코드의 실행 흐름으로 돌아가야 하기 때문에 반환 주소로의 점프와,필요한 경우 반환값을 처리 해야 합니다.

## 오버헤드가 있음에도 함수를 사용하는 이유?

함수를 사용하는 주된 이유는 코드의 재사용성, 모듈성, 그리고 유지 보수의 용이성을 높이기 위해서입니다. 함수를 사용하면 비슷한 코드가 여러 곳에 반복되는 것을 피할 수 있고, 각 기능을 독립적인 단위로 분리하여 코드의 가독성을 높이며, 추후 수정이나 확장을 용이하게 할 수 있습니다.

### **함수 호출 시 오버헤드를 줄이는 방법**

함수 호출에 따른 오버헤드를 줄이는 한 가지 방법은 인라인 함수 사용입니다. 인라인 함수는 컴파일 시간에 호출이 아닌 함수 코드 자체가 호출 위치에 삽입되어 오버헤드를 감소시킵니다. Java에서는 JVM이 실행 시간에 인라이닝을 결정합니다. 그러나 명시적으로 인라인을 요청할 수 있는 언어인 Kotlin에서는 **`inline`** 키워드를 사용할 수 있습니다.

### **Java 예시 코드**

```java
//두 수를 더하는 함수
public class Main {
    public static void main(String[] args) {
        int result = addNumbers(num1, num2);
        System.out.println("합계 : " + result);
    }

    private static int addNumbers(int a, int b) {
        return a + b;
    }
}

//JIT 컴파일러가 간단한 계산인걸 파악하고 인라이닝 처리 final,private 등을 사용해 인라이닝 가능성을 증가 시킬 수 있다.
public class Main {
    public static void main(String[] args) {
        int num1 = 10;  // 예시 입력
        int num2 = 20;  // 예시 입력

        // 인라인 처리된 함수의 본문
        int result = num1 + num2;
        
        System.out.println("합계 : " + result);
    }
}
```

## **Kotlin 예시 코드**

Kotlin에서 인라인 함수를 사용하는 예시입니다.

```kotlin
fun main() {
    val result = addNumbers(10, 20)
    println("합계: $result")
}

inline fun addNumbers(a: Int, b: Int): Int = a + b
```

이렇게 **`inline`** 키워드를 사용함으로써, **`addNumbers`** 함수는 호출 위치에 직접 코드가 삽입되어 런타임 시 함수 호출 관련 오버헤드가 감소됩니다. 

### **인라이닝의 과정**

1. **함수 호출의 식별**: 컴파일러는 코드 중에서 함수 호출을 찾습니다. 예를 들어, **`add(a, b)`**라는 함수 호출이 있다면, 컴파일러는 이 호출을 인라이닝의 대상으로 고려할 수 있습니다.
2. **코드 삽입**: 컴파일 시간에, 컴파일러는 **`add(a, b)`** 함수의 본문을 호출된 위치에 직접 삽입합니다. 만약 **`add(a, b)`** 함수가 **`return a + b;`**라는 단일 명령으로 이루어져 있다면, **`add(a, b)`** 호출 자리에 **`a + b`**라는 연산 코드가 그대로 삽입됩니다.
3. **함수 호출 제거**: 원래의 함수 호출 코드는 제거되고, 그 자리에 함수의 코드가 삽입됩니다. 이렇게 하면 함수를 호출하고 반환하는 데 필요한 오버헤드(매개변수 전달, 스택 프레임 관리 등)가 사라지게 됩니다.

### **인라이닝의 장점**

- **성능 향상**: 함수 호출과 반환에 따른 오버헤드가 제거되므로 실행 시간이 단축될 수 있습니다.
- **코드 최적화**: 컴파일러가 생성한 코드가 더욱 최적화될 수 있으며, 추가적인 최적화 기회가 생길 수 있습니다. 예를 들어, 인라인된 코드에서 불필요한 변수 할당을 제거할 수 있습니다.

### **인라이닝의 단점**

- **코드 크기 증가**: 많은 함수를 인라인하면 컴파일된 프로그램의 크기가 커질 수 있습니다. 이는 코드의 캐시 효율성을 떨어뜨려 오히려 성능을 저하시킬 수도 있습니다.
- **컴파일 시간 증가**: 인라이닝은 컴파일 시간을 증가시킬 수 있습니다. 컴파일러가 함수 호출을 찾고, 코드를 삽입하는 과정은 추가적인 계산을 요구하기 때문입니다.
