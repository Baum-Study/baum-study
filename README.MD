## BAUM 스터디

```
👋 스터디한 내용을 정리하는 공간입니다.
```

### Chapter 0

### Chapter 1 - 컴퓨터 구조 시작하기

```
💡 Chapter 1 미션!

  컴퓨터는 0과 1로 표현된 명령어와 데이터만 이해합니다.
  그런데 Java, Kotlin, Javascript와 같은 고급 언어들을 컴퓨터는 어떻게 이해할까요?
```

### Chapter 2 - 데이터

```
💡 Chapter 2 미션!

  incode, decode를 사용한 예시를 작성해볼까요?
```

### Chapter 3 - 명령어

```
💡 Chapter 3 미션!

  연산코드 중 'call', 'return'은 함수가 저장되어 있는 메모리 주소 공간의 명령어들을 모두 실행한 뒤 함수의 위치로 돌아오는 명령어입니다.
  함수를 많이 호출하면 왔다 갔다 하는 오버헤드가 빈번하게 발생하겠죠.
  하지만 이런 단점에도 불구하고 함수를 사용하는 이유는 무엇일까요?
  
  (필수) Java나 Kotlin으로 함수를 사용하는 예시 코드를 작성해볼까요? 
  (선택) 함수 호출 시 오버헤드를 줄일 수 있는 방법을 코드로 작성해볼까요? 
```

### Chapter 4 - CPU의 작동원리

```
💡 Chapter 4 미션!

  이번 챕터에서는 인터럽트에 대해 배웠어요. 
  인터럽트가 없다면 cpu는 계속 해서 외부 장치의 신호를 보내 확인하죠.
  이를 polling이라고 하는데 이것은 cpu의 성능을 낮추게 됩니다.
  
  polling과 인터럽트를 시스템 디자인 패턴에 빗대면 iterator, observer 패턴으로 비교할 수 있을 것 같아요.
  이를 코드로 작성해볼까요?
```