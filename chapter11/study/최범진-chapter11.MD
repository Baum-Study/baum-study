# CPU 스케줄링 개요

CPU 스케줄링은 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 의미합니다.

## 프로세스 우선순위

운영체제는 각 프로세스가 CPU를 효율적으로 사용할 수 있도록 우선순위를 부여합니다. 이는 각 프로세스의 PCB에 명시되며, 이 우선순위를 기준으로 먼저 처리할 프로세스를 결정합니다.

### 입출력 집중 프로세스

입출력 작업이 많은 프로세스들, 예를 들어 비디오 재생이나 디스크 백업 작업 등이 이에 해당합니다. 이러한 프로세스는 실행 상태보다는 입출력을 기다리는 대기 상태(입출력 버스트)에 더 많이 머무르게 됩니다.

### CPU 집중 프로세스

CPU 작업이 많은 프로세스들, 예를 들어 수학 연산, 컴파일, 그래픽 처리 등이 이에 해당합니다. 이러한 프로세스는 대기 상태보다는 실행 상태(CPU 버스트)에 더 많이 머무르게 됩니다.

입출력 장치가 작업을 완료하기 전까지는 대기 상태가 되기 때문에, 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력 대기 상태로 만든 뒤 CPU 집중 프로세스에 CPU를 할당하는 것이 더 효율적입니다. 따라서 두 프로세스가 동시에 요청이 들어오면 입출력 집중 프로세스가 더 높은 우선순위를 갖습니다.

## 스케줄링 큐

운영체제가 매번 모든 PCB를 검사하여 자원을 이용할 프로세스를 결정하는 일은 번거롭고 시간이 많이 걸립니다. 그래서 운영체제는 프로세스들이 줄을 서서 기다리도록 요구합니다. 이를 스케줄링 큐로 구현하고 관리합니다.

스케줄링 큐는 각 프로세스의 요구사항에 맞춰 큐에 삽입하여 관리합니다.

### 준비 큐

CPU를 사용하려는 프로세스들이 대기하는 큐입니다.

- PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다립니다.
- PCB들은 큐에 삽입된 순서대로 실행되지만, 우선순위가 높은 프로세스를 먼저 실행합니다 (무조건 FIFO일 필요는 없습니다).

### 대기 큐

입출력 장치를 사용하기 위해 대기 상태에 있는 프로세스들이 대기하는 큐입니다.

- 같은 장치를 요구하는 프로세스들은 같은 대기 큐에서 기다립니다.
- 입출력이 완료되면 인터럽트가 발생하여, 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾아 준비 상태로 변경한 뒤 대기 큐에서 제거합니다. 제거된 PCB는 준비 큐로 이동합니다.

## 선점형 스케줄링

선점형 스케줄링은 프로세스가 CPU를 사용하고 있더라도 운영체제가 자원을 강제로 빼앗아 다른 프로세스에게 할당할 수 있는 방식입니다.

- 대부분의 운영체제가 사용합니다.
- 프로세스의 자원 독점을 막고 자원을 골고루 배분할 수 있습니다.
- 문맥 교환 과정에서 오버헤드가 발생할 수 있습니다.

## 비 선점형 스케줄링

비 선점형 스케줄링은 프로세스가 자원을 사용하고 있다면 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 방식입니다.

- 선점형 스케줄링에 비해 문맥 교환 과정의 오버헤드가 적습니다.
- 모든 프로세스가 자원을 골고루 사용할 수 없습니다.

# CPU 스케줄링 알고리즘

## 선입 선처리 스케줄링 FCFS (First Come First Served Scheduling)

FCFS는 단순히 준비 큐에 삽입된 순서대로 프로세스를 처리하는 비선점형 스케줄링 방식입니다. 먼저 요청한 프로세스부터 순서대로 CPU를 할당하는 방식으로, 공정해 보이지만 프로세스가 기다리는 시간이 매우 길어질 수 있습니다(호위 효과).

## 최단 작업 우선 스케줄링 SJF (Shortest Job First Scheduling)

SJF는 준비 큐에 삽입된 프로세스 중 CPU 이용 시간이 가장 짧은 프로세스부터 실행하는 스케줄링 방식입니다. 일반적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로도 구현될 수 있습니다.

## 라운드 로빈 스케줄링 RR (Round Robin Scheduling)

RR은 FCFS 스케줄링에 CPU를 사용할 수 있는 정해진 시간을 의미하는 타임 슬라이스 개념을 더한 선점형 스케줄링 방식입니다. 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하며, 각 프로세스에게 할당된 타임 슬라이스가 종료될 시 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤로 삽입되고 문맥 교환이 발생합니다. 타임 슬라이스가 지나치게 크면 FCFS 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있고, 지나치게 작으면 문맥 교환 비용이 커지기 때문에 RR에서는 타임 슬라이스의 크기가 매우 중요합니다.

## 최소 잔여 시간 우선 스케줄링 SRT (Shortest Remaining Time Scheduling)

SRT는 SJF와 RR을 합친 형태의 스케줄링 방식으로, 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 잔여 작업 시간이 가장 적은 프로세스가 선택됩니다.

## 우선순위 스케줄링 (Priority Scheduling)

우선순위 스케줄링은 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘입니다. 우선순위가 같은 프로세스들은 FIFO로 스케줄링됩니다. 준비 큐에 먼저 삽입되었더라도 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들에 의해 실행이 계속 연기되어 기아 현상이 발생할 수 있습니다. 이를 방지하기 위해 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 에이징 기법을 적용할 수 있습니다.

## 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

다단계 큐 스케줄링은 우선순위 스케줄링의 발전된 형태로, 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식입니다. 가장 우선순위가 높은 큐에서 프로세스를 처리하고, 그 큐가 비어있으면 그다음 우선순위 큐를 처리하는 방식으로 작동합니다. 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리하며, 각 큐에 대해 다양한 스케줄링 알고리즘을 적용할 수 있습니다.

## 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링의 발전된 형태로, 프로세스들이 큐 사이를 이동할 수 없는 문제로 인해 발생하는 우선순위가 낮은 프로세스의 기아 현상을 방지하기 위해 보완된 스케줄링 알고리즘입니다. 프로세스들이 큐 사이를 이동할 수 있어 준비 상태의 프로세스를 가장 높은 우선순위 큐에 넣어 타임 슬라이스 동안 실행하고, 실행 시간이 남아 있다면 다음 우선순위 큐로 이동시킵니다. 이렇게 해서 CPU 버스트가 많은 CPU 집중 프로세스들은 자연스럽게 우선순위가 낮은 큐로 이동하게 되며, 반대로 CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 끝납니다. 또한, 낮은 우선순위 큐에서 너무 오래 기다리는 프로세스에는 에이징 기법을 적용하여 기아 현상을 방지합니다.
